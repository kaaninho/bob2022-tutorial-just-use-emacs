#+title: Ideen und Orga

* Struktur

1. Einführung Emacs
2. Emacs Lisp
3. Konfiguration
4. Interessante Major-/Minor-Modes
5. Evil-Mode
6. Eigene Library

* Einführung Emacs

** Geschichte Emacs
** Unterschied zu gängigen IDEs
** Tastenbefehle Basics

C = Strg
M = Alt

C-a   = Strg gedrückt halten und dann a
C-x b = Strg gedrückt halten und dann x,
        beides loslassen und dann b

- Cursor-Bewegung: C-f, C-b, C-p, C-n
- Abbruch: C-g
- Menü: M-x und dann Funktionsnamen eintippen
  -> Beispiel: display-line-numbers-mode

** Emacs Lisp
** Vorgefertigte Emacs-Distros
- Spacemacs
- Doom Emacs

* Emacs Lisp

- Syntax
- Funktion (interactive)

#+begin_src lisp
;; Custom command.
(defun show-current-time ()
  "Show current time."
  (interactive)
  (message (current-time-string)))
#+end_src

* Konfiguration
** Vorgehen init.el

- Erst zusammen Emacs starten
- dann in =init.el= erste 3 Zeilen auskommentieren
- Emacs neustarten
- Stück für Stück einkommentieren und auswerten (=C-x C-e=)

** Weitere Konfigurationen

- ?!use-package?!
- Emacs as Server
*** global settings

(global-line-numbers-mode 1)

*** hooks

- Delete whitespace before saving

  #+begin_src elisp
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  #+end_src

*** paredit-mode

zusammen installieren:

- zu =package=-Liste hinzufügen
- Hooks setzen

#+begin_src lisp
;; Enable Paredit.
(add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
(add-hook 'lisp-mode-hook 'enable-paredit-mode)
#+end_src

- ?Rainbow-Delimiters?

#+begin_src elisp
;; Enable Rainbow Delimiters.
(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
(add-hook 'ielm-mode-hook 'rainbow-delimiters-mode)
(add-hook 'lisp-interaction-mode-hook 'rainbow-delimiters-mode)
(add-hook 'lisp-mode-hook 'rainbow-delimiters-mode)
#+end_src

*** Custom key sequences

- whitespace Ende der Zeile entfernen

#+begin_src lisp
(global-set-key (kbd "C-c d") 'delete-trailing-whitespace)
#+end_src

* Major-/Minor-Modes

- magit
- projectile / project.el / ?persp-mode?
- helm/ivy
- latex
- Coding
  - elixir u lsp-mode
  - clojure u cider-jack-in + REPL
- org-mode
- org-export
- org-agenda und org-capture
- Timeclock
- mu4e
- undo (undo-tree) und Code-Region-undo
- Shell
- Tramp
- Keybindings (Extrem: pro Zeile E-Mail versenden)

- ?Treemacs?

* Eigene Library

** Ideen

- Protokoll-Mode
  - Anwesende: hinzufügen mit E-Mail-Adresse nachschauen
  - Am Schluss: =C-c C-m= verschickt Mail mit Protokoll an alle
  - Johannes Vorschlag: von einem Protokoll auf Unterpunkte von
    vorherigen Protokollen Link erstellen

** Teilnehmer hinzufügen
von http://pragmaticemacs.com/emacs/tweaking-email-contact-completion-in-mu4e/

#+begin_src emacs-lisp
;;; NEEDED?
(require 'subr-x)

;;; NEEDED?
;;my favourite contacts - these will be put at front of list
(setq bjm/contact-file "/home/kaan/.emacs.dvanilla/.contacts")

(defun bjm/read-contact-list ()
  "Return a list of email addresses"
  (with-temp-buffer
    (insert-file-contents bjm/contact-file)
    (split-string (buffer-string) "\n" t)))

(defun bjm/ivy-select-and-insert-contact-anywhere ()
  (interactive)
  (let (contacts-list contact)
    ;;append full sorted contacts list to favourites and delete duplicates
    (setq contacts-list
          (delq nil (delete-dups (append (bjm/read-contact-list)  (hash-table-keys mu4e~contacts)))))
    (setq contact
          (ivy-read "Contact: "
                    contacts-list
                    :re-builder #'ivy--regex
                    :sort nil))
        (unless (equal contact "")
          (insert contact))))
#+end_src


das braucht es glaub gar nicht:

#+begin_src emacs-lisp
(defun bjm/ivy-select-and-insert-contact (&optional start)
  (interactive)
  ;;make sure mu4e contacts list is updated - I was having
  ;;intermittent problems that this was empty but couldn't see why
  (mu4e~request-contacts)
  (let ((mail-abbrev-mode-regexp mu4e~compose-address-fields-regexp)
        (eoh ;; end-of-headers
         (save-excursion
           (goto-char (point-min))
           (search-forward-regexp mail-header-separator nil t)))
        ;;append full sorted contacts list to favourites and delete duplicates
        (contacts-list
         (delq nil (delete-dups (append (bjm/read-contact-list)  (hash-table-keys mu4e~contacts))))))
    (when (and eoh (> eoh (point)) (mail-abbrev-in-expansion-header-p))
      (let* ((end (point))
             (start
              (or start
                  (save-excursion
                    (re-search-backward "\\(\\`\\|[\n:,]\\)[ \t]*")
                    (goto-char (match-end 0))
                    (point))))
             (contact
              (ivy-read "Contact: "
                        contacts-list
                        :re-builder #'ivy--regex
                        :sort nil
                        :initial-input (buffer-substring-no-properties start end))))
        (unless (equal contact "")
          (kill-region start end)
          (insert contact)))))
#+end_src

musste oben =mu4e~sort-contacts-for-completion= rauslöschen, damit es
kompiliert.

hier mal paar sachen, die ich probiert hab:

#+begin_src emacs-lisp
(mu4e~compose-setup-completion)
mu4e~contacts
completion-at-point-functions
(mu4e~compose-complete-contact "joha")
#+end_src

* Vorbereitung für Teilnehmer:innen

- Emacs installieren (>= 26)
- Konfiguration einspielen:
  - Starte Emacs
  - Drücke =Strg und x= und dann =Strg und f=
  - Tippe ein: =~/.emacs.d/init.el=
  - Kopiere Inhalt von FIXME
  - Füge Inhalt ein in Emacs mit =Strg und y=
  - Speichern mit =Strg und x= dann =Strg und s=
  - Schließe Emacs und öffne es wieder
  - Es sollte nach einer (sehr kurzen) Zeit eine Erfolgsmeldung kommen

** init.el für Teilnehmer:innen

*** Einstieg init.el von Simon

 https://github.com/susam/emfy

*** Weiter Snippets

- Undo umbinden

#+begin_src lisp
;; Custom key sequences.
(global-set-key (kbd "C-z") 'undo)
#+end_src

- Am Schluss:
  #+begin_src lisp
  (progn
    (switch-to-buffer "a-random-buffer")
    (insert "\n\nDu hast es geschafft, Emacs ist für das Tutorial eingerichtet!"))
  #+end_
